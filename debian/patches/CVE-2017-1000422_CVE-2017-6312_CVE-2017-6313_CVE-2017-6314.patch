Index: gdk-pixbuf-2.36.5/gdk-pixbuf/io-gif.c
===================================================================
--- gdk-pixbuf-2.36.5.orig/gdk-pixbuf/io-gif.c
+++ gdk-pixbuf-2.36.5/gdk-pixbuf/io-gif.c
@@ -818,6 +818,31 @@ maybe_update (GifContext *context,
                                          context->user_data);
 }
 
+/* Available in gdk-pixbuf 2.36.8 */
+static gint
+_gdk_pixbuf_calculate_rowstride (GdkColorspace colorspace,
+				gboolean      has_alpha,
+				int           bits_per_sample,
+				int           width,
+				int           height)
+{
+	unsigned int channels;
+
+	g_return_val_if_fail (colorspace == GDK_COLORSPACE_RGB, -1);
+	g_return_val_if_fail (bits_per_sample == 8, -1);
+	g_return_val_if_fail (width > 0, -1);
+	g_return_val_if_fail (height > 0, -1);
+
+	channels = has_alpha ? 4 : 3;
+
+	/* Overflow? */
+	if (width > (G_MAXINT - 3) / channels)
+		return -1;
+
+	/* Always align rows to 32-bit boundaries */
+	return (width * channels + 3) & ~3;
+}
+
 static int
 gif_get_lzw (GifContext *context)
 {
@@ -851,13 +876,29 @@ gif_get_lzw (GifContext *context)
                                 pixels[2] = 0;
                                 pixels[3] = 0;
                         }
-                } else
-                        context->frame->pixbuf =
-                                gdk_pixbuf_new (GDK_COLORSPACE_RGB,
-                                                TRUE,
-                                                8,
-                                                context->frame_len,
-                                                context->frame_height);
+                } else {
+                        int rowstride;
+                        guint64 len;
+
+                        rowstride = _gdk_pixbuf_calculate_rowstride (GDK_COLORSPACE_RGB,
+                                                                    TRUE,
+                                                                    8,
+                                                                    context->frame_len,
+                                                                    context->frame_height);
+                        if (rowstride > 0 &&
+                            g_uint64_checked_mul (&len, rowstride, context->frame_height) &&
+                            len <= G_MAXINT) {
+                                context->frame->pixbuf =
+                                        gdk_pixbuf_new (GDK_COLORSPACE_RGB,
+                                                        TRUE,
+                                                        8,
+                                                        context->frame_len,
+                                                        context->frame_height);
+                        } else {
+                                context->frame->pixbuf = NULL;
+                        }
+                }
+
                 if (!context->frame->pixbuf) {
                         g_free (context->frame);
                         g_set_error_literal (context->error,
Index: gdk-pixbuf-2.36.5/gdk-pixbuf/io-icns.c
===================================================================
--- gdk-pixbuf-2.36.5.orig/gdk-pixbuf/io-icns.c
+++ gdk-pixbuf-2.36.5/gdk-pixbuf/io-icns.c
@@ -95,7 +95,8 @@ load_resources (unsigned size, IN gpoint
       blocklen = GUINT32_FROM_BE (header->size);
 
       /* Check that blocklen isn't garbage */
-      if (blocklen > icnslen - (current - bytes))
+      if (blocklen > icnslen - (current - bytes) ||
+	  blocklen < sizeof (IcnsBlockHeader))
         return FALSE;
 
       switch (size)
Index: gdk-pixbuf-2.36.5/gdk-pixbuf/io-ico.c
===================================================================
--- gdk-pixbuf-2.36.5.orig/gdk-pixbuf/io-ico.c
+++ gdk-pixbuf-2.36.5/gdk-pixbuf/io-ico.c
@@ -330,10 +330,8 @@ static void DecodeHeader(guchar *Data, g
 			return;
 		}
 
-		/* We know how many bytes are in the "header" part. */
-		State->HeaderSize = entry->DIBoffset + INFOHEADER_SIZE;
-
-		if (State->HeaderSize < 0) {
+		/* Avoid invoking undefined behavior in the State->HeaderSize calculation below */
+		if (entry->DIBoffset > G_MAXINT - INFOHEADER_SIZE) {
 			g_set_error (error,
 			             GDK_PIXBUF_ERROR,
 			             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
@@ -341,6 +339,9 @@ static void DecodeHeader(guchar *Data, g
 			return;
 		}
 
+		/* We know how many bytes are in the "header" part. */
+		State->HeaderSize = entry->DIBoffset + INFOHEADER_SIZE;
+
 		if (State->HeaderSize>State->BytesInHeaderBuf) {
 			guchar *tmp=g_try_realloc(State->HeaderBuf,State->HeaderSize);
 			if (!tmp) {
Index: gdk-pixbuf-2.36.5/gdk-pixbuf/io-tiff.c
===================================================================
--- gdk-pixbuf-2.36.5.orig/gdk-pixbuf/io-tiff.c
+++ gdk-pixbuf-2.36.5/gdk-pixbuf/io-tiff.c
@@ -504,8 +504,15 @@ make_available_at_least (TiffContext *co
         need_alloc = context->used + needed;
         if (need_alloc > context->allocated) {
                 guint new_size = 1;
-                while (new_size < need_alloc)
-                        new_size *= 2;
+                while (new_size < need_alloc) {
+                        if (!g_uint_checked_mul (&new_size, new_size, 2)) {
+                                new_size = 0;
+                                break;
+                        }
+                }
+
+                if (new_size == 0)
+                        return FALSE;
 
                 new_buffer = g_try_realloc (context->buffer, new_size);
                 if (new_buffer) {
